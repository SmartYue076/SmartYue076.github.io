{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/05/26/hello-world/"},{"title":"","text":"C++基础（一） 基础知识C++编译过程 预处理(Preprocessing) 将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。gcc的预处理是预处理器cpp来完成的。（include只做文本插入，在include的位置将头文件展开） 编译(Compilation) 这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定**汇编代码(assembly code)**的过程。 一个cpp文件是一个编译单元。 汇编(Assemble) 汇编过程将上一步的汇编代码转换成**机器码(machine code)**，这一步产生的文件叫做目标文件，是二进制格式。 这一步会为每一个源文件产生一个目标文件。 链接(Linking) 链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file) 宏预处理阶段将宏所写内容替换 宏没有类型检查 在宏外加括号防止运算符优先级错误 在宏后不需要加分号（非C++语句） 头文件把函数原型放到头文件中，在需要调用这个函数的源代码文件中include到这个头文件，能让编译器在编译时知道函数的原型，以确保函数类型的统一 头文件里存放声明（extren变量，函数原型，类或结构体的定义），cpp文件里存放定义 头文件的标准格式 用宏定义防止： 两个头文件相互include时的循环include cpp在include不同头文件时可能产生的重复定义（class不能重复定义） 123# ifndef _MY_H_# define _MY_H_# endif 其他 endl将与设备关联的缓冲区（buffer）中的内容刷到设备中。在调试时应保证”一直”刷新流。否则若程序崩溃，输出可能还是缓冲区，导致对于程序崩溃位置的错误推断 读取数量不定的输入数据可用while (std::in &gt;&gt; value) 当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象状态变为无效，使条件为假 EOF：在Windows中为Ctrl+Z，UNIX为Ctrl+D","link":"/2023/05/26/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%BC%80%E5%A7%8B/"},{"title":"","text":"STL基础六大部件 分配器：为容器分配内存 迭代器：算法只能通过迭代器访问容器 容器 Array定长数组_M_instance：指向数组首元素的指针（int a[10]的a） iterator为指针，traits通过指针特化处理 Vector变长数组start（4B）：指向第一个元素的指针 finish（4B）：指向最后一个元素的下一个指针 end_of_storage（4B）：容器申请的内存空间的最后一个元素的下一个地址 若内存空间不够则申请当前空间两倍的空间 iterator为指针，traits通过指针特化处理 List双向链表node（4B）：指向头节点的指针 iterator里的node为指向当前节点的指针 Forward List单向链表 Deque双端队列queue在内存中每个buffer块离散存储，通过map表记录各buffer块的地址 start（16B）：指向首元素的iterator finish（16B）：指向尾巴元素下一个块的iterator map（4B）：指向map首元素的指针 map_size：map占用内存的大小 cur：指向当前元素的指针 first：指向当前buffer块首元素的指针 last：指向当前buffer块尾元素下一个块的指针 node：指向map对应元素的指针 Queue队列不允许遍历也不提供iterator 可选择list或deque作为底层存储 不可选择vector作为底层存储 Stack栈不允许遍历也不提供iterator 可选择list或deque或vector作为底层存储 Set集合t：红黑树 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加 Map键值对集合t：红黑树 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的 FunctorsTodo Iterator Traits由于算法需要得到iterator的某些属性，对于非指针iterator的结构包含属性，但对于指针类型无法获取。通过iterator traits对于iterator处理","link":"/2023/05/26/%E7%AC%AC%E4%B8%83%E7%AB%A0%20STL/"},{"title":"","text":"C++基础（五） 字符串、向量和数组标准库类型String读写string对象 123string s;cin &gt;&gt; s; //from empty to emptygetline(cin,s); //one line, stop by ENTER 当把string对象和字符（串）字面值混在一条语句时，必须确保加法运算符（+）两侧的运算对象至少一个是string 标准库类型vectorvector是模板而非类型 12345vector&lt;T&gt; v1;vector&lt;T&gt; v2(v1);vector&lt;T&gt; v3 = v1; //same to abovevector&lt;T&gt; v4{a,b,c,...};vector&lt;T&gt; v5 = {a,b,c,...}; //same to above 凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素 数组理解复杂的数组声明（P102-103） 从变量名开始由内往外看，即变量名-数组-变量类型 1234int *ptrs[10]; //含有10个整型指针的数组int (*parrary)[10] = &amp;arr; //指向一个含有10个整数的数组的指针int (&amp;arrREF)[10] = arr; //引用一个含有10个整数的数组int *(&amp;arry)[10] = ptrs; //引用一个含有10个整型指针的数组 指向一个数组的指针+1后指向数组尾部的下一个地址 1234567int arr[2];int(*a)[2] = &amp;arr;int *b = arr;cout &lt;&lt; arr &lt;&lt; endl; //0x61fe08cout &lt;&lt; arr + 1 &lt;&lt; endl; //0x61fe0ccout &lt;&lt; a + 1 &lt;&lt; endl; //0x61fe10 = 0x61fe08 + (4*2)Dcout &lt;&lt; b + 1 &lt;&lt; endl; //0x61fe0c","link":"/2023/05/26/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"},{"title":"","text":"C++基础（二）基本数据类型基本内置类型算术类型 类型 含义 最小尺寸 bool 布尔 未定义 char 字符 8位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 类型转换 当一个算术表达式中既有无符号数又有int值时，int会被转换为无符号数 当从无符号数中减去一个值时，不管这个值是不是无符号数，都必须保证结果不为负（否则为取模后值） 变量变量声明于定义的关系变量声明（declaration）定义了变量的类型和名字，定义（definition）在声明外还申请存储空间 如果只想声明，可在变量名前添加关键字extern 变量只能被定义一次，但是可以多次声明","link":"/2023/05/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"","text":"C++基础（三）指针指针是一个变量，其存储的是值的地址，而不是值本身 使用常规变量时，值是指定的量，而地址是派生量，而指针相反 OOP强调的是在运行阶段（而不是编译阶段）进行决策，提供了灵活性，对于内存管理也更加高效 初始化指针12int* ptr_a;double* ptr_b; 初始化时必须指定所指元素类型，因为对所有指针来说其都是代表一个初始地址，但从该初始地址读多少字节则由指针类型判断 指针也是作为变量存储，只不过其内存空间存的是地址。指针p1,p2有各自的地址&amp;p1,&amp;p2。长度为4B（32位）或8B（64位）。p1,p2表示存储的所指向元素的地址。*p1表示指向元素的值。 指针注意事项在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存（指向不确定）。另外，一定要在对指针提取（*）之前，将指针初始化为一个确定的、适当的地址。 一个未指向任何对象的指针，其地址值为0。有时称之为null指针。任何指针都可以被初始化或令其值为0。 指针不是整型，虽然计算机通常把地址当作整数处理。 123int* pt;pt = 0xB80000000; //invalid, type mismatchpt = (int*)0xB80000000; //valid, type match 指针和数组可以修改指针的值，但数组名是常量不能修改 指针变量加1后，其增加的值等于指向的类型占用的字节数 将一个指针减去另一个指针，获得两个指针的差（必须类型相同，差为地址实际差/变量类型长度），仅在都指向同一数组时有意义 对数组应用sizeof得到的是数组的长度，而对指针应用sizeof得到的是指针的长度 数组指针与指针数组 tell和&amp;tell数值相同，但tell指向数组第一个元素，tell+1将地址值加2。&amp;tell指向整个数组，&amp;tell+1将地址值加2*10=20 123short tell[10];cout&lt;&lt; tell &lt;&lt;endl;cout&lt;&lt; &amp;tell &lt;&lt;endl; 数组指针指向整个数组，初始化为 1short (*pas)[10] = &amp;tell; 指针数组为多个指针变量组成的数组，初始化为 1short *pas[10]; 自由存储空间使用new来分配内存12//typeName * pointer_name = new typeNameint* pn = new int; 123456789101112```typeName*```指声明什么类型的指针，左右两侧的类型必须相同，否则因为读取的块大小不同而访问错误**变量存储在栈（stack）的内存区域中，new从堆（heap）或自由存储（free store）的内存区域分配内存**#### 使用delete释放内存```c++int* ps = new int;delete ps; 这将删除ps所指向的内存，但不会删除ps本身，ps还可指向其他内存空间 需要注意的是： 不要使用delete来释放不是new分配的内存 不要使用delete释放同一个内存两次 对空指针(null pointer)使用delete是安全的 使用new创建动态数组12int* psome = new int [10];delete [] psome; 数组直接通过psome[num]访问 需要注意的是： 如果使用new [] 为数组分配内存，则需要通过delete []来释放 如果使用new为一个实体分配内存，则应使用delete来释放 复杂表达式对于复杂表达式应从右往左读 int *&amp;r = p 表示r首先是对p的引用，其次r是一个int*型的引用 引用 定义时必须初始化 不能改变绑定的指向（内部通过顶层const实现，type * const p） 12int a = 1;int &amp;b = a; //(pointer to b) equal to (pointer to a) 引用间不能赋值 没有引用的引用，没有指针的引用，可以有引用的指针 12int &amp;* p; //illegalvoid f(int *&amp; p); //ok","link":"/2023/05/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/"},{"title":"","text":"C++基础（七） inline函数inline 函数将函数声明为inline可以避免函数调用的开销，空间换时间 调用函数步骤： 返回地址压栈 函数参数压栈 计算返回值 函数部分所有元素出栈，返回值 普通函数与inline函数的汇编代码对比 inline函数不是定义是声明，应该写在头文件里，保证编译器将其作为inline函数展开 宏定义与inline函数的区别 宏定义 inline函数 类型检查 无 有 实现方式 预处理时展开 由编译器实现展开，是否将函数作为inline依赖于编译器的判断 其他 容易引发运算符优先级的问题，不可调试 可以调试","link":"/2023/05/26/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%87%BD%E6%95%B0/"},{"title":"","text":"C++基础（九） static关键字static局部变量static局部变量在当前文件等同于全局变量 static局部变量只能在当前文件访问，其他文件不能通过extern访问 static类static对象的构造在main函数前执行，析构在main函数结束后 static成员变量存在于所有对象且保持一致，可在其他文件访问 不能在初始化列表初始化 需在类外定义，因为class内语句都是声明 static成员函数可通过类名::函数调用，只能使用static成员变量，否则报错，没有this指针，不能访问非static成员 变量。","link":"/2023/05/26/%E7%AC%AC%E4%BA%94%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"","text":"C++基础（四）const限定符const限定符const对象一经创建后其值不能再改变，所以const对象必须初始化 1const int i = 1; 默认情况下，const对象仅在文件内有效。若需在不同文件使用同一const对象，则const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了 1extern const int bufSize; const的引用用于声明引用的const都是底层const，引用本身已默认为顶层const（无法改变指向） const型变量只能由const型引用（底层const） 不能把普通引用绑定到字面值上，需用底层const 非const型变量可以由const型引用，但不可通过引用修改被引用变量值 123int i = 0;const int &amp;r = i;r = 1; //invalid 指针和常量若变量为const，则它的指针或引用必为const 要想存放常量对象的地址，只能使用指向常量的指针（底层const） 指向常量的指针（pointer to const）不能通过指针改变常量值 —— 底层const 123int i = 0;const int *p = &amp;i; // eqal to (int const *p =&amp;i;)*p = 1; //invalid 常量指针（const pointer）必须初始化，而且初始化完成后，其指向的地址不能再改变 —— 顶层const 1234int i = 0;int j = 0;int *const p = &amp;i;p = &amp;j; //invalid 指向常量的常量指针（const pointer to const），包含上述两种特性 12int i = 0;const int *const p = &amp;i; 类和const 函数后加const表示不修改任何成员变量（通过const *this实现 ） 如果类包含const变量，必须通过初始化列表初始化 顶层const和底层const当执行对象的拷贝操作时，顶层const不受影响 底层const要求拷入和拷出的对象必须具有相同的底层const资格，或者两个对象能相互转换。非常量可以转化为常量（等号右侧表达式），反之不行","link":"/2023/05/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94const%E9%99%90%E5%AE%9A%E7%AC%A6/"},{"title":"","text":"C++基础（八） 模版模版函数（template function）为声明不是定义，在使用时根据输入类型定义 使用模版时，不会使用隐式类型转换 类模版里的每个函数都是函数模版，需要在声明前加上template 12345template &lt;typename elemType&gt;class BinaryTree{ private: BTnode&lt;elemType&gt; *_root;}","link":"/2023/05/26/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A8%A1%E7%89%88/"},{"title":"","text":"面向对象编程（二） 引用引用的其他用法引用作为成员变量 函数返回引用，可以将返回值做左值 拷贝构造通过类的其他对象初始化当前对象（有默认拷贝构造方法，成员对成员的拷贝，可能发生对象的嵌套拷贝） 123456789101112131415//During call by valuevoid roster(Person){};Person child(&quot;Ruby&quot;);roster(child); // call copy ctors// During initialization, call copy ctorPerson baby_a(&quot;Fred&quot;);Person baby_b = baby_a;Person baby_c(baby_a); // same as above//During function returnPerson captain(){ Person player(&quot;George&quot;); return player;} T::T(const T&amp;) 建议每个类提供默认构造函数，拷贝构造函数，虚函数 其他private针对类而非对象，可访问另一对象中的private成员 内存分配栈定义：存在于某作用域的一块内存空间，在函数本体内声明的任何变量，其使用的内存都取自于栈。在作用域结束后自动清理 堆定义：操作系统提供的一块全局内存空间，程序可动态分配从中获得若干区块。其生命在做犹豫结束后仍然存在，直到整个程序结束 包含： static local objects global objects heap objects（new） new和deletenew先分配内存后调用构造函数 123456//Complex* pc = new Complex(1,2);//for complier, it transform to follow be likeComplex *pc;void *mem = operator new(sizeof(Complex));//call malloc to allocate memorypc = static_cast&lt;Complex *&gt;(mem); //castpc-&gt;Complex::Complex(1,2); //call ctor delete先调用析构函数后释放内存 1234//delete pc//for complier, it transform to follow be likeComplex::~Complex(pc); //call dtoroperator delete(pc); //call free(pc) to release memory","link":"/2023/05/26/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"","text":"C++基础（六） 表达式后置递增运算符的优先级高于解引用运算符，因此*p++等同于*（p++） 将p+1后返回p的初始值","link":"/2023/05/26/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"","text":"第六章 异常处理当执行throw时，throw后的语句都不执行，控制权转移到与之对应的catch模块 退出catch后，catch模块中的局部变量将会销毁 当异常处理完毕后，异常对象将被销毁 1234567try{ //...}catch (exception_a){ //...}catch (exception_b){ //...} 捕捉catch（对于每个catch执行下述步骤） 判断是否是精确匹配 派生类向基类转换（仅引用和指针类型） （…）匹配所有 其中一个被捕捉，跳过下面的catch 重新抛出一条catch语句通过重新抛出的稻作将异常传递给另一个catch语句 1throw; 其他new申请内存失败返回bad_alloc异常，不是返回0 处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块","link":"/2023/05/26/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"","text":"面向对象编程（一）基础知识类不是实体，对象是实体 成员变量（filed）属于对象 成员函数（member function）属于类 初始化列表列表初始化（initialize list）仅对成员变量初始化。 在构造函数里对成员变量初始化则为先初始化（默认）后赋值，故所有成员变量必须要有默认的初始化方法（成员变量包含其他类但该类没有默认构造函数则会报错）。构造函数无法主动调用。 尽量使用列表初始化 123456class A{ public: int a; A(int i):a(i){}; //initialize list // A(int i):{a=i;} }; 拷贝构造和拷贝赋值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Test{public: Test() : ptr(0) { ptr = new char[1]; ptr[0] = '\\0'; cout &lt;&lt; &quot;call Test()&quot; &lt;&lt; endl; }; Test(const char *c_ptr) { if (c_ptr) { ptr = new char[strlen(c_ptr) + 1]; } else { ptr = new char[1]; ptr[0] = '\\0'; } cout &lt;&lt; &quot;call Test(const char *c_ptr)&quot; &lt;&lt; endl; }; Test(Test &amp;test) { ptr = new char[strlen(test.ptr) + 1]; strcpy(ptr, test.ptr); cout &lt;&lt; &quot;call Test(Test &amp;test)&quot; &lt;&lt; endl; }; Test &amp;operator=(Test &amp;test) { if (this == &amp;test) //1.prevent meaningless copy 2.because will delete later, prevent error test.ptr return *this; delete[] ptr; ptr = new char[strlen(test.ptr) + 1]; strcpy(ptr, test.ptr); cout &lt;&lt; &quot;call copy operator=&quot; &lt;&lt; endl; return *this; }private: char *ptr;};int main(){ Test test; //initialzation,call Test() Test test1(&quot;123&quot;); //initialzation,call Test(const char *c_ptr) Test test2 = test1; //initialzation,call Test(Test &amp;test) Test test3(test1); //initialzation,call Test(Test &amp;test) test3 = test2; //assignment,call copy operator=} 拷贝构造通过类的其他对象初始化当前对象（有默认拷贝构造方法，成员对成员的拷贝，可能发生对象的嵌套拷贝） 123456789101112131415//During call by valuevoid roster(Person){};Person child(&quot;Ruby&quot;);roster(child); // call copy ctors// During initialization, call copy ctorPerson baby_a(&quot;Fred&quot;);Person baby_b = baby_a;Person baby_c(baby_a); // same as above//During function returnPerson captain(){ Person player(&quot;George&quot;); return player;} T::T(const T&amp;) 建议每个类提供默认构造函数，拷贝构造函数，虚函数 继承访问属性 访问限制符\\访问位置 当前类 子类 类外 public 可以 可以 可以 protected 可以 可以 不可以 private 可以 不可以 不可以 若子类中含有与父类同名函数（函数名相同，参数列表个数和类型），父类的函数会被隐藏。（仅C++如此） 123456789101112131415161718class A{ public: int i; A(int a):i(a){}; void print(){cout&lt;&lt;&quot;A::print()&quot;&lt;&lt;endl;}; void print(int a){cout&lt;&lt;&quot;A::print(int i)&quot;&lt;&lt;endl;};};class B:public A{ public: B(int a):A(a){}; void print(){cout&lt;&lt;&quot;B::print()&quot;&lt;&lt;endl;};};int main(){ B b(4); b.print(2); //ERROR, cant found print(int a) in A} 友元类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元 1234567class Sales_data{ friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); public: //... private: //...}; 一般来说，最好在类定义开始货结束前的集中位置声明友元 友元的声明只指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么就必须在友元声明外再专门对函数进行一次声明 相同类的对象互为友元 虚函数向上造型（upcasting）指将派生类的引用或指针转化为父类的引用或指针 1234567891011121314151617181920212223242526272829303132333435class Base{public: Base() : i(0) {} void print() { cout &lt;&lt; &quot;Base print&quot; &lt;&lt; endl; }private: int i;};class Derived : public Base{public: void print() { cout &lt;&lt; &quot;Derived print&quot; &lt;&lt; endl; }};void test_print(Base &amp;a){ a.print();}int main(){ Base test; Derived test2; test_print(test2); //Base print return 0;} 虚函数：使派生类各自定义适合自己版本的函数，当使用基类的引用（或指针）调用一个虚函数时将发生动态绑定（父类加上virtual即生效，但最好子父类都加上virtual） 静态绑定：编译时确定调用的函数 动态绑定：运行时确定调用的函数 如果派生类没有覆盖基类的虚函数，则派生类会直接继承基类中的版本 对象增加vptr，指向当前对象的类的vtable（属于类，保存存储虚函数的地址） 虚函数运行方式为访问vptr—访问vtable—访问函数指针—访问函数 如果有一个虚函数，则需将析构函数设为虚函数，以处理新增变量 C++默认静态绑定 派生类虚函数的形参类型个数，返回值类型必须和基类一致，否则为重载（除非返回类型时类本身的指针或引用） 其他private针对类而非对象，可访问另一对象中的private成员","link":"/2023/05/26/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"title":"","text":"线程池原理与实现 B站讲解视频：线程池原理与实现 线程池线程池是什么线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。 使用线程池可以带来一系列好处： 降低资源消耗（系统资源）：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高线程的可管理性（系统资源）：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。 提高响应速度（任务响应）：任务到达时，无需等待线程创建即可立即执行。 提供更多更强大的功能（功能扩展）：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。 线程池解决的问题线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题： 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。 接口C Thread Pool（Github） Function example Description thpool_init(4) Will return a new threadpool with 4 threads. thpool_add_work(thpool, (void*)function_p, (void*)arg_p) Will add new work to the pool. Work is simply a function. You can pass a single argument to the function if you wish. If not, NULL should be passed. thpool_wait(thpool) Will wait for all jobs (both in queue and currently running) to finish. thpool_destroy(thpool) This will destroy the threadpool. If jobs are currently being executed, then it will wait for them to finish. thpool_pause(thpool) All threads in the threadpool will pause no matter if they are idle or executing work. thpool_resume(thpool) If the threadpool is paused, then all threads will resume from where they were. thpool_num_threads_working(thpool) Will return the number of currently working threads. 接口实现thpool_init(int num_threads) 创建线程池基本结构 1234567891011typedef struct thpool_{ thread **threads; /* pointer to threads */ volatile int num_threads_alive; /* threads currently alive */ volatile int num_threads_working; /* threads currently working */ pthread_mutex_t thcount_lock; /* used for thread count etc */ pthread_cond_t threads_all_idle; /* signal to thpool_wait */ jobqueue jobqueue; /* job queue */} thpool_;thpool_p = (struct thpool_*)malloc(sizeof(struct thpool_)); 初始化队列 1jobqueue_init(&amp;thpool_p-&gt;jobqueue); 创建线程池中的线程 1thpool_p-&gt;threads = (struct thread**)malloc(num_threads * sizeof(struct thread *)); 初始化线程 12for (n=0; n&lt;num_threads; n++){ thread_init(thpool_p, &amp;thpool_p-&gt;threads[n], n); 关注点 对于资源申请失败的处理，防止异常退出和内存泄漏 由于malloc申请失败是不报错的，在malloc之后一定要判断返回的指针值是否为NULL。如果对于这个空指针不做处理，那之后对于空指针的操作会引发Segmentation Fault而程序直接core了。还有就是在异常处理中要对已经申请的资源释放掉，否则会引发内存泄漏 对于传值和传址的区分，传值传的是值的拷贝 ​ 如果对于指针理解得比较困难的开发者可以看看南科大于仕琪老师的C/C++教程 int thpool_add_work(thpool_ *thpool_p, void (*function_p)(void *), void *arg_p) 创建任务 1newjob = (struct job *)malloc(sizeof(struct job)); 配置函数和函数参数 12newjob-&gt;function = function_p;newjob-&gt;arg = arg_p; 将任务加入队列 1jobqueue_push(&amp;thpool_p-&gt;jobqueue, newjob); 关注点 对于队列没有任务时的处理 不是采用轮询的方式，而是使用条件变量，在有任务时唤醒条件变量 对于函数指针类型转换的处理 ​ 自定义的函数原型可以与api的原型不一致，但需要进行强制类型转换， (void *(*)(void *))里面中间的*表示当前为函数指针，右边的void *表示参数类型，左边的void *表示返回值类型。切记不要让编译器去做这种类型转换，可能会有意想不到的问题。（pthread_create参数里最后的函数指针的参数这样写好像就不必转换类型了） 1234567// int pthread_create(pthread_t *restrict thread,// const pthread_attr_t *restrict attr,// void *(*start_routine)(void *),// void *restrict arg);// static void *thread_do(struct thread *thread_p)pthread_create(&amp;(*thread_p)-&gt;pthread, NULL, (void *(*)(void *))thread_do, (*thread_p)); void thpool_destroy(thpool_ *thpool_p) 结构体元素的复位 1234threads_keepalive = 0; double TIMEOUT = 1.0; time_t start, end; double tpassed = 0.0; 通过条件变量的唤醒终止线程 123456789101112while (tpassed &lt; TIMEOUT &amp;&amp; thpool_p-&gt;num_threads_alive){ bsem_post_all(thpool_p-&gt;jobqueue.has_jobs); time(&amp;end); tpassed = difftime(end, start);}while (thpool_p-&gt;num_threads_alive){ bsem_post_all(thpool_p-&gt;jobqueue.has_jobs); sleep(1);} 任务队列的释放 1jobqueue_destroy(&amp;thpool_p-&gt;jobqueue); 其余堆上元素的释放 1234567int n;for (n = 0; n &lt; threads_total; n++){ thread_destroy(thpool_p-&gt;threads[n]);}free(thpool_p-&gt;threads);free(thpool_p); 关注点 对于线程释放的处理 ​ 可以定义一个条件变量来唤醒所有线程，然后通过一个表示是否存活的布尔值来作为while循环的终止条件，达到优雅的释放 别漏，别漏，别漏 ​ 一定要细心检查，不要忘记释放堆上的资源 static void thread_hold(int sig_id) 注册信号量句柄 1234567891011121314151617181920// in function thread_dostruct sigaction act;sigemptyset(&amp;act.sa_mask);act.sa_flags = 0;act.sa_handler = thread_hold;if (sigaction(SIGUSR1, &amp;act, NULL) == -1){ err(&quot;thread_do(): cannot handle SIGUSR1&quot;);}// handler functionstatic void thread_hold(int sig_id){ (void)sig_id; threads_on_hold = 1; while (threads_on_hold) { sleep(1); }} 通过信号量发送暂停信号 12345int n;for (n = 0; n &lt; thpool_p-&gt;num_threads_alive; n++){ pthread_kill(thpool_p-&gt;threads[n]-&gt;pthread, SIGUSR1);} void thpool_resume(thpool_ *thpool_p)修改循环条件值 12(void)thpool_p;threads_on_hold = 0; 总结我们明白了线程池是什么（What），线程池有什么用（Why）以及接口的具体实现（How）。这个线程池项目中有许多值得学习的地方，比方说对于条件变量的使用，对于资源的申请和释放方法，是很优质的开源项目。另外，项目里也有可以扩充的点，比方说把队列改成比方说把队列改成优先级队列，那这样要考虑的东西就更多了，比方说它任务是可抢占还是不可抢占的，有任务的调度顺序的变化，这可能会牵涉到线程逻辑的大修改，如果大家感兴趣的话可以试试～ 参考资料Java线程池实现原理及其在美团业务中的实践","link":"/2023/06/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"}],"tags":[],"categories":[],"pages":[]}